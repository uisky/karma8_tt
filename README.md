# Тестовое задание: Karma8


## Анализ задачи

При заявленных в описании задачи вероятностях, в базе на 5 миллионов пользователей будет

* 1 млн юзеров с подпиской.
* Если время окончания подписки равномерно распределено в течение года, то это 2740 истеканий подписки в сутки
  и, если мы уведомляем дважды, за 1 и 3 дня, то 5480 писем в день.
* В худшем сценарии, когда `send_email()` работает 10 секунд, отправка займёт 15 часов 12 минут в сутки.
  В принципе, мы укладываемся, но если поголовье юзеров удвоится, то send_email() нужно параллелить.
* 85% пользователей не подтверждают свой емейл, поэтому 850 тысяч подписчиков придётся проверять ещё более медленной
  `check_email()`. Это 2238 вызова (и столько же денег) в день, что при худшем сценарии составляет 37 часов 20 минут в сутки;
  следовательно, какими-то проверками придётся пренебречь.

Баттлнеком задачи является долгое время работы функций `send_email()` и `check_email()`. 
Поэтому сервис будет состоять из двух частей: регулярно запускаемый скрипт, который отбирает
юзеров с заканчивающейся пропиской и ставит их в очередь, и менеджер очереди, который
разбирается с отправкой писем. Второй сервис можно параллелить.

> За один и за три дня до истечения срока подписки, нужно отправить письмо пользователю 

Под словом "день" будем понимать сутки (24 часа), тем более, что часовых поясов пользователей мы не знаем.
При этом в секундной точности уведомлений необходимости нет, так что разрешим некоторую допустимую
погрешность.

> Необходимо регулярно отправлять емейлы об истечении срока подписки на те емейлы, на которые письмо точно дойдёт
> ...на валидный емейл письмо точно дойдёт

Подменив формальную логику здравым смыслом, истрактуем это так, что на невалидный, но прочеканный
емейл письмо точно не дойдёт.

Также будем считать, что письмо точно дойдёт юзерам, у которых `confirmed = 1` — раз он нажал на ссылку в письме,
значит, получил его. Мог, конечно, воспользоваться одноразовым ящиком, но отнесёмся с уважением к его желанию
оградиться от нашего спама и закроем на это глаза.



## Реализация

### Выборка пользователей (notifier.php)

В сущности, нам нужно с периодичностью `precision` секунд брать список юзеров, у которых 
`now() + period < validts < now() + period + precision`,
где `period` — это период, за который мы предупреждаем об окончании подписки, а `precision` — это точность,
с которой мы отправляем уведомления. Будем начало и конец временного интервала далее называть `start` и `finish`.
На этом этапе имеем пока `start = now() + period, finish = now() + period + precision`.

Также в запросе сразу отбросим безнадёжных в плане получения корреспонденции юзеров с `confirmed = 0 AND checked = 1 AND valid = 0`.

Ни `cron`, ни монотонные таймеры `systemd` в своих спецификациях не обещают секундной точности; инициализация нашего скрипта
также может занять ненулевое время. Это значит, что запуская скрипт по крону, например, каждый час в 0 минут 0 секунд,
мы рискуем пропустить юзеров, у которых подписка заканчивается ровно в 0 минут 0 секунд того же часа через сутки или трое.
Поэтому введём *состояние приложения*: некий мэппинг вида

```
{
    period: last_finish,
    ...
}
```

Состояние будем хранить в БД, в таблице с одним текстовым полем, сериализовав в JSON — не появится зависимости от
файловой системы.

Теперь при каждом запуске, если есть стейт, можно положить `start = state[period], finish = now() + period + precision`,
а в конце записывать `state[period] = finish`, что обеспечит непрерывность обрабатываемых интервалов и скрипт можно
запускать с любой периодичностью.

Если вдруг скрипт не запускался более суток, то люди могут за 10 минут до окончания подписки получить письмо
"Ваша подписка закончится через три дня". Обработаем и этот случай:

```
if (state[period] <= now() + period - 12h) {
    start = now() + period - 12h;
} else {
    start = state[period];
}
```

Величина «12 часов» взята из предположения, что «через сутки и 12 часов» для людей ещё считается как «завтра», а вот
«через день и 23 часа» — уже воспринимается как «почти два дня». С более точным значением этой константы пусть
разбирается маркетинг. Фокус-группы, там, интервью, A/B тестирование, вот это всё.

Также недурно было бы защититься от повторной отправки писем. Для этого будем просто хранить во вспомогательной
таблице `notifications_done` информацию о том, какие письма мы уже ставили в очередь, в виде `(user_id, period, validts)` и
джойнить её по всем трём полям в запросе на получение пользователей. Из этой таблицы можно смело удалять строки с
`validts + period <= now()`, поэтому она не будет разрастаться.

Таким образом, запрос на получение юзеров для отправки уведомлений будет выглядеть так:

```sql
SELECT users.* 
FROM users 
LEFT JOIN notifications_done ON
    notifications_done.user_id = users.id AND 
    notifications_done.period = :period AND
    notifications_done.validts = users.validts
WHERE 
    users.validts BETWEEN :start AND :finish AND 
    notifications_done.user_id IS NULL AND
    NOT (users.confirmed = 0 AND users.valid = 0 AND users.checked = 1)
ORDER BY users.validts
```

Так как по таблице `users` мы делаем выборки с `WHERE validts BETWEEN x AND y`, то нам очень пригодится
BTREE-индекс по полю `users.validts`.


### Менеджер очереди (mailer.php)

В виду того, что очередь одновременно требуется реализовать самостоятельно и не демонстрировать разнообразия владеемых
технологий, то реализуем её очень просто. В Redis будет ключ типа `LIST`. Постановка задачи в очередь
добавляет в конец того листа JSON-сериализованный объект задачи вида `{action, created, expires, payload}`.

Менеджер в цикле делает `LPOP` из списка (получив NULL спит секунду и повторяет `LPOP`), десериализует
строку, пропускает задачи у которых `expires < now()`, а затем пытается вызвать функцию `action_{$action}`,
передав ей в аргументах `payload`.

В очередь попадают задачи на отправку письма юзеру. Пусть у таких задач `action = "notify"`, а в `payload` будет
строка из таблицы `users` и `period` — срок, за который мы этого юзера предупреждаем. В `expires` запишем
время, когда задача более неактуальна — это `user.validts - period + 12h`.

Функция-обработчик действия `notify` для юзеров с `confirmed = 1 OR valid = 1` просто вызывает медленную
функцию `send_email()`.

Юзеров, которые не прошли проверку, хорошо бы проверить, но эту проверку лучше делать с меньшим приоритетом,
чем отправка уведомлений. В продакшн-условиях это решалось бы приоритетом задач, но мы просто введём вторую очередь
(ещё один ключ типа `LIST` в редисе), куда будем помещать задачи с `action = "check"`, а в цикле выборки задач
из очереди будем залезать туда, только если основная очередь пуста.

Обработчик действия `check` вызывает медленную `check_email()`, в случае успеха записывает ему в базу
`valid = 1` и вызывает `send_email()`. Время протухания такой задачи равно времени протухания задачи, её породившей.

Функция `check_email()` у нас платная. Не худо было бы как-нибудь ограничить бюджет на её использование.
Пусть мы разрешаем в сутки потратить не более `BUDGET` денег. Этот бюджет будем передавать менеджеру очереди
при запуске. В редисе будем хранит оставшийся бюджет на сегодня, сбрасывать его в `BUDGET` при смене суток,
и вызывать `check_email()` только если сегодняшний бюджет ненулевой.

В описанной схеме есть одно узкое место: за время, пока менеджер очереди добрался до задачи обработки
какого-нибудь юзера, информация о нём в БД может измениться (напрмер, юзер продлил подписку, не дожидаясь
напоминания). Решается это просто: в обработчиках действий нужно обновлять информацию из базы
(`SELECT * FROM users WHERE id = {$user["id"]}`), что, конечно, несколько увеличит нагрузку на БД,
хоть и не критично, так как выборки по первичному ключу в InnoDB быстры.

Используемые ключи Redis:

* `mailer:queue:mail`: очередь отправки писем
* `mailer:queue:check`: очередь проверки юзеров
* `mailer:budget-daily`: дневной бюджет
* `mailer:budget-today`: остаток сегодняшнего бюджета
* `mailer:last-check-date` дата последнего вызова `check_email()`




## Как запустить и потестить

Предполагается, что в системе есть интерпретатор PHP >= 8.1, composer, MySQL и Redis.

Сперва поставим зависимости:
```shell
$ sudo mysql -e "CREATE USER 'tt_romakhin'@'localhost' IDENTIFIED BY 'nothing'; CREATE DATABASE tt_romakhin; GRANT ALL PRIVILEGES ON tt_romakhin.* TO 'tt_romakhin'@'localhost'"
$ composer install
```

Нам понадобится пустая (желательно) база данных mysql. В файле `config.php` пропишем
доступ к ней:

```php
<?php
return [
    "db_host" => "localhost",
    "db_name" => "tt_romakhin",
    "db_user" => "tt_romakhin",
    "db_password" => "nothing"
];
```

Затем нужно создать тестовые данные (этот же скрипт создаст и все вспомогательные таблицы):

```bash
$ ./fake_data.php -c 2023-01-01 2024-01-01 5000000
```

Теперь запустим сервис рассылки писем из очереди, выделив ему сто рублей в день на `check_email()``:

```bash
$ ./mailer.php --budget-daily 100
```

И в другом терминале стартанём сам рассыльщик уведомлений, сказав в параметрах, что хотим уведомлять
людей за 1 и за 3 суток :
```bash
$ ./notifier.php 1 3
```

Теперь идём в терминал, где запущен `mailer.php` и любуемся работой очереди.

Проверить работу системы можно в таблице `notifier_log`. куда записываются отправленные письма:

```sql
SELECT
    u.*, from_unixtime(u.validts), log.*
FROM users u
    LEFT JOIN notifier_log log ON u.email = log.rcpt
WHERE 
    u.validts BETWEEN unix_timestamp(timestamp('2023-09-29 13:00:00')) AND unix_timestamp(timestamp('2023-09-29 14:00:00'))
ORDER BY u.validts;
```


## Титры

Соискатель: Дмитрий Ромахин: [tg](http://t.me/uisky), [cv](http://romakhin.ru/cv)
